<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mimic++: mimic++, a modern and (mostly) macro free mocking framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mimic++<span id="projectnumber">&#160;v5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">mimic++, a modern and (mostly) macro free mocking framework </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2_r_e_a_d_m_e"></a></p>
<p><a href="https://codecov.io/gh/DNKpp/mimicpp"><img src="https://codecov.io/gh/DNKpp/mimicpp/graph/badge.svg?token=T9EpgyuyUi" alt="codecov" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/github/DNKpp/mimicpp"><img src="https://coveralls.io/repos/github/DNKpp/mimicpp/badge.svg" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> <a href="https://app.codacy.com/gh/DNKpp/mimicpp/dashboard?utm_source=gh&amp;utm_medium=referral&amp;utm_content=&amp;utm_campaign=Badge_grade"><img src="https://app.codacy.com/project/badge/Grade/b852271c6e8742fe8a1667e679dc422b" alt="Codacy Badge" class="inline"/></a> <a href="https://app.codacy.com/gh/DNKpp/mimicpp/dashboard?utm_source=gh&amp;utm_medium=referral&amp;utm_content=&amp;utm_campaign=Badge_coverage"><img src="https://app.codacy.com/project/badge/Coverage/b852271c6e8742fe8a1667e679dc422b" alt="Codacy Badge" class="inline"/></a> <a href="https://dnkpp.github.io/mimicpp/"><img src="https://img.shields.io/badge/docs-doxygen-blue" alt="Documentation" class="inline"/></a></p>
<hr  />
<h1><a class="anchor" id="autotoc_md37"></a>
Author</h1>
<p>Dominic Koepke <br  />
 Mail: <a href="#" onclick="location.href='mai'+'lto:'+'dnk'+'pp'+'201'+'1@'+'gma'+'il'+'.co'+'m'; return false;">DNKpp2011@gmail.com</a></p>
<h1><a class="anchor" id="autotoc_md38"></a>
Table of Contents</h1>
<ul>
<li>Introduction<ul>
<li>Core Design</li>
<li>Examples</li>
<li>Portability</li>
<li>Special Acknowledgement</li>
</ul>
</li>
<li>Customizability<ul>
<li>Stringification</li>
<li>Matchers</li>
<li>Policies</li>
<li>Bring your own string- and char-types</li>
<li>Call-Conventions</li>
</ul>
</li>
<li>Integration<ul>
<li>Installation<ul>
<li>CMake</li>
<li>Single-Header</li>
</ul>
</li>
<li>Test Framework</li>
</ul>
</li>
<li>Documentation</li>
<li>Testing</li>
<li>License</li>
<li>Known Issues</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md40"></a>
Introduction</h1>
<p><code>mimic++</code> is a c++20 mocking framework, which aims to offer a natural end expressive syntax, without constantly resorting to macros. To be honest, macros cannot be completely avoided, but they can at least be reduced to a very minimum.</p>
<p>The one thing, that this framework does different than all other (or at least all I am aware of) mocking framework is, that mock objects explicitly are function objects, thus directly callable. It's simple and straight forward.</p>
<p>As I'm mainly working on template or functional-style code, I wanted something simpler than always creating explicit mock types for the simplest of use cases. So, <code><a class="el" href="d2/d48/classmimicpp_1_1_mock.html" title="A Mock type, which fully supports overload sets.">mimicpp::Mock</a></code> objects can directly be used as functional objects, but they can also be used as member objects and thus serve as actual member functions.</p>
<p>If you are curious, have a look at the <a href="https://dnkpp.github.io/mimicpp/">documentation</a>, investigate the examples folder or play around online at <a href="https://godbolt.org/z/fYavvqfeM">godbolt.org</a>.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Core Design</h2>
<p>The framework is designed with two core concepts in mind: Mocks and Expectations. Mocks can be used to define behaviour on a per test-case basis, without the necessity of creating dozens of types. The go-to example is, if you have a custom type, which somehow makes a connection to a concrete database, you do not want to setup an actual database connection during your test runs. You then simply install a database mock, which then yields the exact replies as it were defined for that particular case: the so called "Expectations".</p>
<p>So, Mocks and Expectations are going together hand in hand.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Examples</h2>
<details >
<summary >
Mocks as function objects</summary>
<p></p>
<p>As already said, <code><a class="el" href="d2/d48/classmimicpp_1_1_mock.html" title="A Mock type, which fully supports overload sets.">mimicpp::Mock</a></code>s are already function objects.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d0/db9/mimic_09_09_8hpp.html">mimic++/mimic++.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// it&#39;s recommended to pull these sub-namespaces out, because then the expectation setup becomes much more readable</span></div>
<div class="line"><span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"><span class="keyword">namespace </span>matches = <a class="code hl_namespace" href="dd/d7b/namespacemimicpp_1_1matches.html">mimicpp::matches</a>;</div>
<div class="line"><span class="keyword">namespace </span>finally = <a class="code hl_namespace" href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a>;</div>
<div class="line"><span class="keyword">namespace </span>then = <a class="code hl_namespace" href="d9/d4c/namespacemimicpp_1_1then.html">mimicpp::then</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>matches::_;   <span class="comment">// That&#39;s the wildcard matcher, which matches everything</span></div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Mocks are function objects.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;int(std::string, std::optional&lt;int&gt;)&gt; mock{};     <span class="comment">// actually enables just `int operator ()(std::string, std::optional&lt;int&gt;)`</span></div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(<span class="stringliteral">&quot;Hello, World&quot;</span>, _)                  <span class="comment">// requires the first argument to match the string &quot;Hello, World&quot;; the second has no restrictions</span></div>
<div class="line">                and expect::at_least(1)                             <span class="comment">// controls, how often the whole expectation must be matched</span></div>
<div class="line">                and expect::arg&lt;0&gt;(!matches::range::is_empty())     <span class="comment">// addtionally requires the first argument to be not empty (note the preceeding !)</span></div>
<div class="line">                and expect::arg&lt;1&gt;(matches::ne(std::nullopt))       <span class="comment">// requires the second argument to compare unequal to &quot;std::nullopt&quot;</span></div>
<div class="line">                and expect::arg&lt;1&gt;(matches::lt(1337))               <span class="comment">// and eventually to be less than 1337</span></div>
<div class="line">                and then::apply_arg&lt;0&gt;(                             <span class="comment">// That&#39;s a side-effect, which get&#39;s executed, when a match has been made.</span></div>
<div class="line">                    [](std::string_view str) { std::cout &lt;&lt; str; }) <span class="comment">//     This one writes the content of the first argument to std::cout.</span></div>
<div class="line">                and finally::returns(42);                           <span class="comment">// And, when matches, returns 42</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> result = mock(<span class="stringliteral">&quot;Hello, World&quot;</span>, 1336);                        <span class="comment">// matches</span></div>
<div class="line">    REQUIRE(42 == result);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Mocks can be overloaded.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;</div>
<div class="line">        int(std::string, std::optional&lt;int&gt;),                   <span class="comment">// same as previous test</span></div>
<div class="line">        void() const                                            <span class="comment">// enables `void operator ()() const` (note the const specification)</span></div>
<div class="line">    &gt; mock{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call()                               <span class="comment">// setup an expectation for the void() overload</span></div>
<div class="line">                and expect::twice();                            <span class="comment">// should be matched twice</span></div>
<div class="line"> </div>
<div class="line">    mock();                                                     <span class="comment">// first match</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// you can always create new expectations as you need them, even if the object is already in use</span></div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.expect_call(!matches::range::is_empty(), 42)        <span class="comment">// you can always apply matches directly; if just a value is provided, defaults to matches::eq</span></div>
<div class="line">                and expect::once()                                      <span class="comment">// once() is the default, but you can state that explicitly</span></div>
<div class="line">                and finally::throws(std::runtime_error{<span class="stringliteral">&quot;some error&quot;</span>});  <span class="comment">// when matches, throws an exception</span></div>
<div class="line"> </div>
<div class="line">    REQUIRE_THROWS(mock(<span class="stringliteral">&quot;Test&quot;</span>, 42));                           <span class="comment">// ok, matched</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// still a pending expectation for void() overload</span></div>
<div class="line">    std::as_const(mock)();                                      <span class="comment">// explicitly call from a const object</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassmimicpp_1_1_mock_html"><div class="ttname"><a href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a></div><div class="ttdoc">A Mock type, which fully supports overload sets.</div><div class="ttdef"><b>Definition</b> Mock.hpp:390</div></div>
<div class="ttc" id="agroup___m_o_c_k_html_ga7e7d68eefb8f3cba28422f62bcf2f90a"><div class="ttname"><a href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a></div><div class="ttdeci">#define SCOPED_EXP</div><div class="ttdoc">Shorthand variant of MIMICPP_SCOPED_EXPECTATION.</div><div class="ttdef"><b>Definition</b> ExpectationBuilder.hpp:289</div></div>
<div class="ttc" id="amimic_09_09_8hpp_html"><div class="ttname"><a href="d0/db9/mimic_09_09_8hpp.html">mimic++.hpp</a></div></div>
<div class="ttc" id="anamespacemimicpp_1_1expect_html"><div class="ttname"><a href="d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a></div><div class="ttdef"><b>Definition</b> ControlPolicy.hpp:252</div></div>
<div class="ttc" id="anamespacemimicpp_1_1finally_html"><div class="ttname"><a href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a></div><div class="ttdef"><b>Definition</b> ExpectationPolicies.hpp:404</div></div>
<div class="ttc" id="anamespacemimicpp_1_1matches_html"><div class="ttname"><a href="dd/d7b/namespacemimicpp_1_1matches.html">mimicpp::matches</a></div><div class="ttdef"><b>Definition</b> Matcher.hpp:288</div></div>
<div class="ttc" id="anamespacemimicpp_1_1then_html"><div class="ttname"><a href="d9/d4c/namespacemimicpp_1_1then.html">mimicpp::then</a></div><div class="ttdef"><b>Definition</b> ExpectationPolicies.hpp:576</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
Mocks as member functions</summary>
<p></p>
<p><code><a class="el" href="d2/d48/classmimicpp_1_1_mock.html" title="A Mock type, which fully supports overload sets.">mimicpp::Mock</a></code>s can also serve as member functions. Sure, there are some limitations, but for the most cases it works well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d0/db9/mimic_09_09_8hpp.html">mimic++/mimic++.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>finally = <a class="code hl_namespace" href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// let&#39;s build a function, which actually expects an object and requires .get() member function,</span></div>
<div class="line"><span class="comment">// This member function then should return something printable</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> foo(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; obj.get();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Mocks can be used as member functions.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>Mock</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;int() const&gt; get{}; <span class="comment">// that serves as the .get() member function</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Mock mock{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.get.expect_call()</div>
<div class="line">                and finally::returns(42);</div>
<div class="line"> </div>
<div class="line">    foo(mock);      <span class="comment">// fine, foo calls the get() member-function</span></div>
<div class="line">}</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
Mocking interfaces</summary>
<p></p>
<p><code>mimic++</code> also provides helpers for interface mocking.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d0/db9/mimic_09_09_8hpp.html">mimic++/mimic++.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>finally = <a class="code hl_namespace" href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// let&#39;s say, we have the following interface</span></div>
<div class="line"><span class="keyword">class </span>Interface</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~Interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and a function, which this time actually requires an interface.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> foo(<span class="keyword">const</span> Interface&amp; obj)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; obj.get();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Interfaces can be mocked.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>Derived</div>
<div class="line">        : <span class="keyword">public</span> Interface</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        ~Derived() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// this generates the override method and a mock object named get_</span></div>
<div class="line">        <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#ga6d5cb660367ff702eb85c0257b8d474b">MOCK_METHOD</a>(get, <span class="keywordtype">int</span>, (), <span class="keyword">const</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Derived mock{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> mock.get_.expect_call()      <span class="comment">// note the _ suffix. That&#39;s the name of the mock object.</span></div>
<div class="line">                and finally::returns(42);</div>
<div class="line"> </div>
<div class="line">    foo(mock);        <span class="comment">// fine, foo calls the get() member-function, which forwards the call to the mock object get_.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup___m_o_c_k___i_n_t_e_r_f_a_c_e_s_html_ga6d5cb660367ff702eb85c0257b8d474b"><div class="ttname"><a href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#ga6d5cb660367ff702eb85c0257b8d474b">MOCK_METHOD</a></div><div class="ttdeci">#define MOCK_METHOD</div><div class="ttdoc">Shorthand variant of MIMICPP_MOCK_METHOD.</div><div class="ttdef"><b>Definition</b> InterfaceMock.hpp:507</div></div>
</div><!-- fragment --><p>Sometimes, an interface method may also have several overloads. <code>mimic++</code> directly supports overriding overload-sets. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d0/db9/mimic_09_09_8hpp.html">mimic++/mimic++.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>finally = <a class="code hl_namespace" href="d2/d8d/namespacemimicpp_1_1finally.html">mimicpp::finally</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// let&#39;s say, we have the following interface, with an overload-set</span></div>
<div class="line"><span class="keyword">class </span>Interface</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~Interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span>&amp; get() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; get() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and a function, using the const overload of that interface</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> foo(<span class="keyword">const</span> Interface&amp; obj)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; obj.get();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;Interface overload-sets are directly supported.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>Derived</div>
<div class="line">        : <span class="keyword">public</span> Interface</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        ~Derived() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// this generates two overloads of get and a single mock object named get_</span></div>
<div class="line">        <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gafd903cfdd4f9496f29642c9b9e3859c0">MOCK_OVERLOADED_METHOD</a>(</div>
<div class="line">            get,                                    <span class="comment">// the name of the overload-set</span></div>
<div class="line">            <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gaf7eca902448118eaf4359c12be4ed098">ADD_OVERLOAD</a>(<span class="keywordtype">int</span>&amp;, ()),                 <span class="comment">// enables &quot;int&amp; operator ()()&quot; on the mock</span></div>
<div class="line">            <a class="code hl_define" href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gaf7eca902448118eaf4359c12be4ed098">ADD_OVERLOAD</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp;, (), <span class="keyword">const</span>));   <span class="comment">// enables &quot;const int&amp; operator ()() const&quot; on the mock</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Derived mock{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> std::as_const(mock).get_.expect_call()   <span class="comment">// As we expect the const overload to be used, we must explicitly select that overload.</span></div>
<div class="line">                and finally::returns(42);               <span class="comment">// The returned reference is valid, as long as the expectation is alive.</span></div>
<div class="line"> </div>
<div class="line">    foo(mock);        <span class="comment">// fine, foo calls the get() const member-function, which forwards the call to the mock object get_ as before.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup___m_o_c_k___i_n_t_e_r_f_a_c_e_s_html_gaf7eca902448118eaf4359c12be4ed098"><div class="ttname"><a href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gaf7eca902448118eaf4359c12be4ed098">ADD_OVERLOAD</a></div><div class="ttdeci">#define ADD_OVERLOAD</div><div class="ttdoc">Shorthand variant of MIMICPP_ADD_OVERLOAD.</div><div class="ttdef"><b>Definition</b> InterfaceMock.hpp:519</div></div>
<div class="ttc" id="agroup___m_o_c_k___i_n_t_e_r_f_a_c_e_s_html_gafd903cfdd4f9496f29642c9b9e3859c0"><div class="ttname"><a href="de/dcd/group___m_o_c_k___i_n_t_e_r_f_a_c_e_s.html#gafd903cfdd4f9496f29642c9b9e3859c0">MOCK_OVERLOADED_METHOD</a></div><div class="ttdeci">#define MOCK_OVERLOADED_METHOD</div><div class="ttdoc">Shorthand variant of MIMICPP_MOCK_OVERLOADED_METHOD.</div><div class="ttdef"><b>Definition</b> InterfaceMock.hpp:513</div></div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
Watching object-instances</summary>
<p></p>
<p><code><a class="el" href="d3/d5d/classmimicpp_1_1_watched.html" title="CRTP-type, inheriting first from all Watchers and then Base, thus effectively couple them all togethe...">mimicpp::Watched</a></code> helper can report destruction and relocations of object-instances.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d0/db9/mimic_09_09_8hpp.html">mimic++/mimic++.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>expect = <a class="code hl_namespace" href="d3/d18/namespacemimicpp_1_1expect.html">mimicpp::expect</a>;</div>
<div class="line"><span class="keyword">namespace </span>then = <a class="code hl_namespace" href="d9/d4c/namespacemimicpp_1_1then.html">mimicpp::then</a>;</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;LifetimeWatcher and RelocationWatcher can trace object instances.&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="d3/d5d/classmimicpp_1_1_watched.html">mimicpp::Watched</a>&lt;</div>
<div class="line">        <a class="code hl_class" href="d2/d48/classmimicpp_1_1_mock.html">mimicpp::Mock</a>&lt;void()&gt;,</div>
<div class="line">        <a class="code hl_class" href="db/d98/classmimicpp_1_1_lifetime_watcher.html">mimicpp::LifetimeWatcher</a>,</div>
<div class="line">        <a class="code hl_class" href="da/d45/classmimicpp_1_1_relocation_watcher.html">mimicpp::RelocationWatcher</a>&gt; watched{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> watched.expect_destruct();</div>
<div class="line">    <span class="keywordtype">int</span> relocationCounter{};</div>
<div class="line">    <a class="code hl_define" href="d8/d12/group___m_o_c_k.html#ga7e7d68eefb8f3cba28422f62bcf2f90a">SCOPED_EXP</a> watched.<a class="code hl_function" href="da/d45/classmimicpp_1_1_relocation_watcher.html#a1ab88c2edc2f770ea8c9d1e8c0ca62a2">expect_relocate</a>()</div>
<div class="line">                and then::invoke([&amp;] { ++relocationCounter; })</div>
<div class="line">                and expect::at_least(1);</div>
<div class="line"> </div>
<div class="line">    std::optional wrapped{std::move(watched)};  <span class="comment">// satisfies one relocate-expectation</span></div>
<div class="line">    std::optional other{std::move(wrapped)};    <span class="comment">// satisfies a second relocate-expectation</span></div>
<div class="line">    wrapped.reset();                            <span class="comment">// won&#39;t require a destruct-expectation, as moved-from objects are considered dead</span></div>
<div class="line">    other.reset();                              <span class="comment">// fulfills the destruct-expectation</span></div>
<div class="line">    REQUIRE(2 == relocationCounter);            <span class="comment">// let&#39;s see, how often the instance has been relocated</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassmimicpp_1_1_lifetime_watcher_html"><div class="ttname"><a href="db/d98/classmimicpp_1_1_lifetime_watcher.html">mimicpp::LifetimeWatcher</a></div><div class="ttdoc">A watcher type, which reports it's destructor calls.</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:57</div></div>
<div class="ttc" id="aclassmimicpp_1_1_relocation_watcher_html"><div class="ttname"><a href="da/d45/classmimicpp_1_1_relocation_watcher.html">mimicpp::RelocationWatcher</a></div><div class="ttdoc">A watcher type, which reports it's move-constructor and -assignment calls.</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:199</div></div>
<div class="ttc" id="aclassmimicpp_1_1_relocation_watcher_html_a1ab88c2edc2f770ea8c9d1e8c0ca62a2"><div class="ttname"><a href="da/d45/classmimicpp_1_1_relocation_watcher.html#a1ab88c2edc2f770ea8c9d1e8c0ca62a2">mimicpp::RelocationWatcher::expect_relocate</a></div><div class="ttdeci">auto expect_relocate()</div><div class="ttdoc">Begins a relocation-expectation construction.</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:273</div></div>
<div class="ttc" id="aclassmimicpp_1_1_watched_html"><div class="ttname"><a href="d3/d5d/classmimicpp_1_1_watched.html">mimicpp::Watched</a></div><div class="ttdoc">CRTP-type, inheriting first from all Watchers and then Base, thus effectively couple them all togethe...</div><div class="ttdef"><b>Definition</b> ObjectWatcher.hpp:398</div></div>
</div><!-- fragment --><p></p>
</details>
<h2><a class="anchor" id="autotoc_md43"></a>
Portability</h2>
<p><code>mimic++</code> is designed to work on any c++20 conforming compiler - independent of the underlying platform or architecture. This is achieved by always staying within the language bounds and is continuously checked by the extensive ci/cd workflow, which keeps track of many different configurations. In fact <code>mimic++</code> is known to work on Windows, Ubuntu and MacOs with <code>x86_x64</code> and <code>x86_x86</code> architectures. For a more complete overview head over to the Testing section.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Special Acknowledgement</h2>
<p>This framework is highly inspired by the well known <a href="https://github.com/rollbear/trompeloeil">trompeloeil</a>, which I have used myself for several years now. It's definitly not bad, but sometimes feels a little bit dated and some macros do not play very well with formatting tools and the like. If you need a pre-c++20 mocking-framework, you should definitly give it a try.</p>
<p>Fun fact: <code>mimic++</code> uses <code>trompeloeil</code> for it's own test suite :D</p>
<hr  />
<h1><a class="anchor" id="autotoc_md46"></a>
Customizability</h1>
<p>A framework should be a useful tool that can be used in a variety of ways. However, it should not be a foundation that limits the house to be built on it. For this reason <code>mimic++</code> offers various ways for customization: E.g. users may create their own expectation policies and integrate them seamlessly, without changing any line of the <code>mimic++</code> code-base.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Stringification</h2>
<p><code>mimic++</code> can not provide stringification for any type out there, but it's often very useful to see a proper textual reprensentation of an object, when a test fails. <code>mimic++</code> will use <code>std::format</code> for <code>formattable</code> types, but sometimes that is not, what we want, as users for example want to have an alternative stringification just for testing purposes. Users can therefore add their specializations of the <code><a class="el" href="da/d68/classmimicpp_1_1custom_1_1_printer.html" title="User may add specializations, which will then be used during print calls.">mimicpp::custom::Printer</a></code> type and thus tell <code>mimic++</code> how a given type shall be printed.</p>
<p>Custom specializations will always be prefered over any pre-existing printing methods, thus users may even override the stringification of the internal report types.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Matchers</h2>
<p>Matchers are used to check, whether arguements satisfy some requirements. There are already many existing matchers available, but users often have special needs. <code>mimic++</code> provides a very generic <code><a class="el" href="dc/d5e/classmimicpp_1_1_predicate_matcher.html" title="Generic matcher and the basic building block of most of the built-in matchers.">mimicpp::PredicateMatcher</a></code>, which is often already sufficient. But, if one needs full control, just start with a fresh type (without any inheritance) and start building your own. They just have to match the <code><a class="el" href="df/d23/conceptmimicpp_1_1matcher__for.html">mimicpp::matcher_for</a></code> concept. For more information, head to the documentation.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Policies</h2>
<p>There are multiple types of policie, depending on the task they shall fulfill. The expectation policy has full control, whether a match can be made or shall be rejected, while the finalize policy determines, what a mock shall do, when it actually matched (like returning a value or throwing an exception). They can implement arbitrary logic, so feel free to experiment. There is no base type requirement, they simply have to satisfy either the <code><a class="el" href="dd/d1d/conceptmimicpp_1_1expectation__policy__for.html" title="Determines, whether the given type satisfies the requirements of an expectation-policy for the given ...">mimicpp::expectation_policy_for</a></code>, <code><a class="el" href="d4/df8/conceptmimicpp_1_1control__policy.html" title="Determines, whether the given type satisfies the requirements of a control-policy.">mimicpp::control_policy</a></code> or <code><a class="el" href="d9/d64/conceptmimicpp_1_1finalize__policy__for.html" title="Determines, whether the given type satisfies the requirements of a finalize-policy for the given sign...">mimicpp::finalize_policy_for</a></code>.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Bring your own string- and char-types</h2>
<p>If you are working with a huge framework, chances are good, that this framework utilizes a custom string- or even char-type (like <code>QChar</code> and <code>QString</code> from Qt). They may look different, but in fact they are just strings, so it would be nice to make them fully compatible with the existing string-matchers. <code>mimic++</code> supports that, users just have to provide some trait-specializations. For more infos, have a look into the string section of the doxygen documentation.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Call-Conventions</h2>
<p>Call-Conventions are a rather controversial topic, as the c++-language definition doesn't know or say anything about them by itself. On the other hand-side, the microsoft <code>COM</code> framework for example makes use of the <code>__stdcall</code> call-convention; so it's safe to say, that at least some compilers have support for these kind of specifications; and of course users need the possibility to make use of these features. As they are by no means portable, <code>mimic++</code> does not define anything by itself, but does instead provide an easy ( macro) tool to users, which they can use to make the framework compatible with any call-convention they need: <code>MIMICPP_REGISTER_CALL_CONVENTION</code></p>
<hr  />
<h1><a class="anchor" id="autotoc_md53"></a>
Documentation</h1>
<p>The documenation is generated via <code>doxygen</code>. Users can do this locally by enabling both, the <code>MIMICPP_CONFIGURE_DOXYGEN</code> and <code>MIMICPP_ENABLE_GENERATE_DOCS</code>, cmake options and building the target <code>mimicpp-generate-docs</code> manually.</p>
<p>The documentation for the <code>main</code> branch is always available on the <a href="https://dnkpp.github.io/mimicpp/">github-pages</a>; for the <code>development</code> branch it is also available on the <code>dev-gh-pages</code> branch, but unfortunatly not directly viewable on the browser. Every release has the generated documentation attached.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md55"></a>
Integration</h1>
<p><code>mimic++</code> is a head-only library. Users can easily enjoy all features by simply including the <code>mimic++/mimic++.hpp</code> header. Of course one can be more granular and include just what's necessary. The choice is yours.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Installation</h2>
<h3><a class="anchor" id="autotoc_md57"></a>
CMake</h3>
<p>This framework is header-only and completely powered by cmake, thus the integration into a cmake project is straight-forward. </p><div class="fragment"><div class="line">target_link_libraries(</div>
<div class="line">    &lt;your_target_name&gt;</div>
<div class="line">    PUBLIC</div>
<div class="line">    mimicpp::mimicpp</div>
<div class="line">)</div>
</div><!-- fragment --><p>Users can either pick a commit in the <code>main</code> branch or a version tag and utilize the cmake <code>FetchContent</code> module: </p><div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">    mimicpp</div>
<div class="line">    GIT_REPOSITORY https://github.com/DNKpp/mimicpp</div>
<div class="line">    GIT_TAG        &lt;any_commit_hash_or_tag&gt;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(mimicpp)</div>
<div class="line"># do not forget linking via target_link_libraries as shown above</div>
</div><!-- fragment --><p>As an alternative, I recommend the usage of <a href="https://github.com/cpm-cmake/CPM.cmake">CPM</a>, which is a featureful wrapper around the <code>FetchContent</code> functionality: </p><div class="fragment"><div class="line">include(CPM.cmake) # or include(get_cpm.cmake)</div>
<div class="line"> </div>
<div class="line">CPMAddPackage(&quot;gh:DNKpp/mimicpp#&lt;any_commit_hash_or_tag&gt;&quot;)</div>
<div class="line"># do not forget linking via target_link_libraries as shown above</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md58"></a>
Single-Header</h3>
<p>As an alternative each release has a header file named <code>mimic++-amalgamated.hpp</code> attached, which contains all definitions (except for the specific test-framework adapters) and can be simply dropped into any c++20 project (or used on <a href="https://godbolt.org">godbolt.org</a>. After that, users may also just pick the appropriate adapter header for their desired test-framework and put that into their project aswell.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Test Framework</h2>
<p>Mocking frameworks usually do not exist for their own, as they are in fact just an advanced technice for creating tests. Instead, they should work together with any existing test framework out there. <code>mimic++</code> provides the <code>IReporter</code> interface, which in fact serves as a bridge from <code>mimic++</code> into the utilized test framework. <code>mimic++</code> provides some concrete reporter implementations for well known test frameworks, but users may create custom adapters for any test framework or simply use the default reporter. For more details have a look into the <code>reporting</code> section in the documentation.</p>
<p>Official adapters exist for the following frameworks:</p>
<ul>
<li><a href="https://github.com/boostorg/test">Boost.Test</a> (tested with v1.85.0)</li>
<li><a href="https://github.com/catchorg">Catch2</a> (tested with v3.7.1)</li>
<li><a href="https://github.com/doctest/doctest">Doctest</a> (tested with v2.4.11)</li>
<li><a href="https://github.com/google/googletest">GTest</a> (tested with v1.15.2)</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md61"></a>
Testing</h1>
<p><code>mimic++</code> utilizes a strict testing policy, thus each official feature is well tested. The effect of those test-cases are always tracked by the extensive ci, which checks the compilation success, test cases outcomes and coverage on dozens of different os, compiler and build configurations. By default, all configurations assume a <code>x86_x64</code>-architecture. In addition, a few configurations have been added specifically for the <code>x86_x86</code>-architecture.</p>
<p>For the test builds the flags <code>-Wall -Wextra -Wpedantic -Werror</code> (on MSVC <code>/W4 /WX</code>) are set. This is done to make sure, that <code>mimic++</code> won't flood your build output with endless warnings (or even worse: break your builds), if you enable these flags in your own projects.</p>
<p>The coverage is generated via <code>gcov</code> and evaluated by <a href="https://app.codacy.com/gh/DNKpp/mimicpp">codacy</a>, <a href="https://codecov.io/gh/DNKpp/mimicpp">codecov</a> and <a href="https://coveralls.io/github/DNKpp/mimicpp">coveralls</a>.</p>
<p>Nevertheless, even with very high effort, the 100% code-coverage is without reach. I do my best to cover each branch, but even now the coverage percentage varies between the individual tools. The goal is to be close to 100% as possible.</p>
<p>On the other hand-side, there is a whole range of code which doesn't even get investigated by these tools: templates (and macros). <code>mimic++</code> has <b>a lot</b> of templating code at the very heart, which is at least of equal effort to get right (and tested). So, treat the coverage percentage with a grain of salt.</p>
<details >
<summary >
CI Tests</summary>
<p></p>
<p>The listed configurations are explicitly tested, but other do probably work, too. As new compilers become available, they will be added to the workflow, but older compilers will probably never be supported.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Symbol   </th><th class="markdownTableHeadCenter">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">works    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">*   </td><td class="markdownTableBodyCenter">works with caveats    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">does not work    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">not tested   </td></tr>
</table>
<p><b>Windows</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">OS   </th><th class="markdownTableHeadCenter">Compiler   </th><th class="markdownTableHeadCenter">c++-20   </th><th class="markdownTableHeadCenter">c++-23   </th><th class="markdownTableHeadCenter">std-format   </th><th class="markdownTableHeadCenter">fmt    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows 2022   </td><td class="markdownTableBodyCenter">msvc   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows 2022   </td><td class="markdownTableBodyCenter">clangCl   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p><b>Linux</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Compiler   </th><th class="markdownTableHeadCenter">libstdc++   </th><th class="markdownTableHeadCenter">libc++   </th><th class="markdownTableHeadCenter">c++-20   </th><th class="markdownTableHeadCenter">c++-23   </th><th class="markdownTableHeadCenter">std-format   </th><th class="markdownTableHeadCenter">fmt    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clang-16   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">clang-17   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clang-18   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">*   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gcc-12   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gcc-13   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gcc-14   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p><b>macOS</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Compiler   </th><th class="markdownTableHeadCenter">libstdc++   </th><th class="markdownTableHeadCenter">libc++   </th><th class="markdownTableHeadCenter">c++-20   </th><th class="markdownTableHeadCenter">c++-23   </th><th class="markdownTableHeadCenter">std-format   </th><th class="markdownTableHeadCenter">fmt    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AppleClang-16.0.6   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">AppleClang-17.0.6   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AppleClang-18.1.6   </td><td class="markdownTableBodyCenter">?   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p></p>
</details>
<hr  />
<h1><a class="anchor" id="autotoc_md63"></a>
License</h1>
<p><a href="LICENSE_1_0.txt">BSL-1.0</a> (free, open source)</p>
<div class="fragment"><div class="line">         Copyright Dominic &quot;DNKpp&quot; Koepke 2024 - 2024</div>
<div class="line">Distributed under the Boost Software License, Version 1.0.</div>
<div class="line">   (See accompanying file LICENSE_1_0.txt or copy at</div>
<div class="line">         https://www.boost.org/LICENSE_1_0.txt)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md65"></a>
Known Issues</h1>
<h2><a class="anchor" id="autotoc_md66"></a>
Clang-18.1 + libc++</h2>
<p>Date: 25.09.2024</p>
<p>This combination introduced a regression regarding the <code>std::invocable</code> concept and a default parameter of type <code>std::source_location</code>. On this version, all invocable checks will fail, but the <code>std::is_invocable</code> trait still works as expected. Unfortunatly this can not solved easily by this lib, sorry for that.</p>
<p>Clang-17 and Clang-19 do not suffer from this issue. For more information have a look <a href="https://github.com/llvm/llvm-project/issues/106428">here</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Dec 15 2024 for mimic++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
